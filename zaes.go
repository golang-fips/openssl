// Code generated by cmd/genaesmodes. DO NOT EDIT.

//go:build !cmd_go_bootstrap

package openssl

import "crypto/cipher"

type cipherWithCBC struct {
	aesCipher
}

type cipherWithCTR struct {
	aesCipher
}

type cipherWithCBC_CTR struct {
	aesCipher
	cipherWithCBC
	cipherWithCTR
}

type cipherWithGCM struct {
	aesCipher
}

type cipherWithCBC_GCM struct {
	aesCipher
	cipherWithCBC
	cipherWithGCM
}

type cipherWithCTR_GCM struct {
	aesCipher
	cipherWithCTR
	cipherWithGCM
}

type cipherWithCBC_CTR_GCM struct {
	aesCipher
	cipherWithCBC
	cipherWithCTR
	cipherWithGCM
}

func newAESBlock(c *evpCipher, kind cipherKind) cipher.Block {
	aes := aesCipher{c}
	var block cipher.Block
	supportsCBC := loadCipher(kind, cipherModeCBC) != nil
	supportsCTR := loadCipher(kind, cipherModeCTR) != nil
	supportsGCM := loadCipher(kind, cipherModeGCM) != nil
	switch {
	case !supportsCBC && !supportsCTR && !supportsGCM:
		block = aes
	case supportsCBC && !supportsCTR && !supportsGCM:
		block = cipherWithCBC{aes}
	case !supportsCBC && supportsCTR && !supportsGCM:
		block = cipherWithCTR{aes}
	case supportsCBC && supportsCTR && !supportsGCM:
		block = cipherWithCBC_CTR{aes,
			cipherWithCBC{aes},
			cipherWithCTR{aes},
		}
	case !supportsCBC && !supportsCTR && supportsGCM:
		block = cipherWithGCM{aes}
	case supportsCBC && !supportsCTR && supportsGCM:
		block = cipherWithCBC_GCM{aes,
			cipherWithCBC{aes},
			cipherWithGCM{aes},
		}
	case !supportsCBC && supportsCTR && supportsGCM:
		block = cipherWithCTR_GCM{aes,
			cipherWithCTR{aes},
			cipherWithGCM{aes},
		}
	case supportsCBC && supportsCTR && supportsGCM:
		block = cipherWithCBC_CTR_GCM{aes,
			cipherWithCBC{aes},
			cipherWithCTR{aes},
			cipherWithGCM{aes},
		}
	default:
		panic("unreachable")
	}
	return block
}
