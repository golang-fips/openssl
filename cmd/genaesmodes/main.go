// genaesmodes generates the types and functions necessary to support the various
// combinations of optional AES cipher modes.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strings"
)

var inputPath = flag.String("in", "", "input path (required)")
var aesModes = flag.String("modes", "", "comma-separated list of AES modes to generate (required)")
var outputPath = flag.String("out", "", "output path (default stdout)")

func init() {
	log.SetFlags(log.Llongfile)
	log.SetOutput(os.Stderr)
}

func main() {
	flag.Parse()

	if *inputPath == "" {
		log.Fatalf("input path is required")
	}
	if *aesModes == "" {
		log.Fatalf("AES modes are required")
	}

	var b bytes.Buffer
	fmt.Fprint(&b, "// Code generated by cmd/genaesmodes. DO NOT EDIT.\n\n")

	pkg := "openssl"
	if gopackage := os.Getenv("GOPACKAGE"); gopackage != "" {
		pkg = gopackage
	}
	fmt.Fprint(&b, "//go:build !cmd_go_bootstrap\n\n")
	fmt.Fprintf(&b, "package %s\n\n", pkg)
	fmt.Fprint(&b, `import "crypto/cipher"`+"\n\n")

	generate(&b)

	generated, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatalf("failed to format generated code: %v", err)
	}

	if *outputPath != "" {
		err := os.WriteFile(*outputPath, generated, 0o644)
		if err != nil {
			log.Fatalf("failed to write output file: %v\n", err)
		}
	} else {
		_, _ = os.Stdout.Write(generated)
	}
}

// modePerm represents a single AES mode and whether it is supported.
type modePerm struct {
	mode      string
	supported bool
}

// structNameForPerms returns the name of the struct that represents the given
// set of AES modes.
func structNameForPerms(modes []modePerm) string {
	var structName string
	for _, mode := range modes {
		if mode.supported {
			if structName != "" {
				structName += "_"
			}
			structName += mode.mode
		}
	}
	return "cipherWith" + structName
}

// permutations returns all possible permutations of the given AES modes.
func permutations(modes []string) [][]modePerm {
	var perms [][]modePerm
	for i := 0; i < 1<<len(modes); i++ {
		var modesForPerm []modePerm
		for j, mode := range modes {
			modesForPerm = append(modesForPerm, modePerm{mode: mode, supported: i&(1<<j) != 0})
		}
		perms = append(perms, modesForPerm)
	}
	return perms
}

// generate generates the types and functions necessary to support the various
// combinations of optional AES cipher modes.
func generate(w io.Writer) {
	modes := strings.Split(*aesModes, ",")
	generateStructs(w, modes)
	generateNewAESBlock(w, modes)
}

// generateStructs generates the structs that represent the various combinations
// of optional AES cipher modes.
func generateStructs(w io.Writer, modes []string) {
	perms := permutations(modes)
	for _, perm := range perms {
		var nsup int
		for _, mode := range perm {
			if mode.supported {
				nsup++
			}
		}
		if nsup == 0 {
			// No supported modes, so no need for a struct.
			continue
		}
		structName := structNameForPerms(perm)
		fmt.Fprintf(w, "type %s struct {\n", structName)
		fmt.Fprint(w, "\taesCipher\n")
		if nsup > 1 {
			for _, mode := range perm {
				if !mode.supported {
					continue
				}
				fmt.Fprintf(w, "\tcipherWith%s\n", mode.mode)
			}

		}
		fmt.Fprint(w, "}\n\n")
	}
}

func generateNewAESBlock(w io.Writer, modes []string) {
	fmt.Fprint(w, "func newAESBlock(c *evpCipher, kind cipherKind) cipher.Block {\n")
	fmt.Fprint(w, "\taes := aesCipher{c}\n")
	fmt.Fprint(w, "\tvar block cipher.Block\n")
	for _, mode := range modes {
		fmt.Fprintf(w, "\tsupports%s := loadCipher(kind, cipherMode%s) != nil\n", mode, mode)
	}
	fmt.Fprint(w, "\tswitch {\n")
	perms := permutations(modes)
	for _, perm := range perms {
		generateCase(w, perm)
	}
	fmt.Fprint(w, "\tdefault:\n")
	fmt.Fprint(w, "\t\tpanic(\"unreachable\")\n")
	fmt.Fprint(w, "\t}\n")
	fmt.Fprint(w, "\treturn block\n")
	fmt.Fprint(w, "}\n\n")
}

func generateCase(w io.Writer, modes []modePerm) {
	fmt.Fprint(w, "\tcase ")
	for i, mode := range modes {
		if i > 0 {
			fmt.Fprint(w, " && ")
		}
		if !mode.supported {
			fmt.Fprint(w, "!")
		}
		fmt.Fprintf(w, "supports%s", mode.mode)
	}
	fmt.Fprint(w, ":\n")
	structName := structNameForPerms(modes)
	var nsup int
	for _, mode := range modes {
		if mode.supported {
			nsup++
		}
	}
	if nsup == 0 {
		fmt.Fprint(w, "\t\tblock = aes\n")
	} else if nsup == 1 {
		fmt.Fprintf(w, "\t\tblock = %s{aes}\n", structName)
	} else {
		fmt.Fprintf(w, "\t\tblock = %s{aes,\n", structName)
		for _, mode := range modes {
			if !mode.supported {
				continue
			}
			fmt.Fprintf(w, "\t\t\tcipherWith%s{aes},\n", mode.mode)
		}
		fmt.Fprint(w, "\t\t}\n")
	}
}
